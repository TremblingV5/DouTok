// Code generated by Kitex v0.4.4. DO NOT EDIT.

package commentdomainservice

import (
	"context"
	"fmt"
	commentDomain "github.com/TremblingV5/DouTok/kitex_gen/commentDomain"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return commentDomainServiceServiceInfo
}

var commentDomainServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "CommentDomainService"
	handlerType := (*commentDomain.CommentDomainService)(nil)
	methods := map[string]kitex.MethodInfo{
		"AddComment":   kitex.NewMethodInfo(addCommentHandler, newAddCommentArgs, newAddCommentResult, false),
		"RmComment":    kitex.NewMethodInfo(rmCommentHandler, newRmCommentArgs, newRmCommentResult, false),
		"ListComment":  kitex.NewMethodInfo(listCommentHandler, newListCommentArgs, newListCommentResult, false),
		"CountComment": kitex.NewMethodInfo(countCommentHandler, newCountCommentArgs, newCountCommentResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "commentDomain",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.4.4",
		Extra:           extra,
	}
	return svcInfo
}

func addCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentDomain.DoutokAddCommentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentDomain.CommentDomainService).AddComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AddCommentArgs:
		success, err := handler.(commentDomain.CommentDomainService).AddComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddCommentResult)
		realResult.Success = success
	}
	return nil
}
func newAddCommentArgs() interface{} {
	return &AddCommentArgs{}
}

func newAddCommentResult() interface{} {
	return &AddCommentResult{}
}

type AddCommentArgs struct {
	Req *commentDomain.DoutokAddCommentReq
}

func (p *AddCommentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(commentDomain.DoutokAddCommentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AddCommentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AddCommentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AddCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AddCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AddCommentArgs) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokAddCommentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddCommentArgs_Req_DEFAULT *commentDomain.DoutokAddCommentReq

func (p *AddCommentArgs) GetReq() *commentDomain.DoutokAddCommentReq {
	if !p.IsSetReq() {
		return AddCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type AddCommentResult struct {
	Success *commentDomain.DoutokAddCommentResp
}

var AddCommentResult_Success_DEFAULT *commentDomain.DoutokAddCommentResp

func (p *AddCommentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(commentDomain.DoutokAddCommentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AddCommentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AddCommentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AddCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AddCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AddCommentResult) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokAddCommentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddCommentResult) GetSuccess() *commentDomain.DoutokAddCommentResp {
	if !p.IsSetSuccess() {
		return AddCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentDomain.DoutokAddCommentResp)
}

func (p *AddCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rmCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentDomain.DoutokRmCommentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentDomain.CommentDomainService).RmComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RmCommentArgs:
		success, err := handler.(commentDomain.CommentDomainService).RmComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RmCommentResult)
		realResult.Success = success
	}
	return nil
}
func newRmCommentArgs() interface{} {
	return &RmCommentArgs{}
}

func newRmCommentResult() interface{} {
	return &RmCommentResult{}
}

type RmCommentArgs struct {
	Req *commentDomain.DoutokRmCommentReq
}

func (p *RmCommentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(commentDomain.DoutokRmCommentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RmCommentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RmCommentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RmCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RmCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RmCommentArgs) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokRmCommentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RmCommentArgs_Req_DEFAULT *commentDomain.DoutokRmCommentReq

func (p *RmCommentArgs) GetReq() *commentDomain.DoutokRmCommentReq {
	if !p.IsSetReq() {
		return RmCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RmCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type RmCommentResult struct {
	Success *commentDomain.DoutokAddCommentResp
}

var RmCommentResult_Success_DEFAULT *commentDomain.DoutokAddCommentResp

func (p *RmCommentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(commentDomain.DoutokAddCommentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RmCommentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RmCommentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RmCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RmCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RmCommentResult) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokAddCommentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RmCommentResult) GetSuccess() *commentDomain.DoutokAddCommentResp {
	if !p.IsSetSuccess() {
		return RmCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RmCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentDomain.DoutokAddCommentResp)
}

func (p *RmCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func listCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentDomain.DoutokListCommentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentDomain.CommentDomainService).ListComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListCommentArgs:
		success, err := handler.(commentDomain.CommentDomainService).ListComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListCommentResult)
		realResult.Success = success
	}
	return nil
}
func newListCommentArgs() interface{} {
	return &ListCommentArgs{}
}

func newListCommentResult() interface{} {
	return &ListCommentResult{}
}

type ListCommentArgs struct {
	Req *commentDomain.DoutokListCommentReq
}

func (p *ListCommentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(commentDomain.DoutokListCommentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListCommentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListCommentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListCommentArgs) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokListCommentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListCommentArgs_Req_DEFAULT *commentDomain.DoutokListCommentReq

func (p *ListCommentArgs) GetReq() *commentDomain.DoutokListCommentReq {
	if !p.IsSetReq() {
		return ListCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type ListCommentResult struct {
	Success *commentDomain.DoutokListCommentResp
}

var ListCommentResult_Success_DEFAULT *commentDomain.DoutokListCommentResp

func (p *ListCommentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(commentDomain.DoutokListCommentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListCommentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListCommentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListCommentResult) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokListCommentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListCommentResult) GetSuccess() *commentDomain.DoutokListCommentResp {
	if !p.IsSetSuccess() {
		return ListCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentDomain.DoutokListCommentResp)
}

func (p *ListCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func countCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(commentDomain.DoutokCountCommentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(commentDomain.CommentDomainService).CountComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountCommentArgs:
		success, err := handler.(commentDomain.CommentDomainService).CountComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountCommentResult)
		realResult.Success = success
	}
	return nil
}
func newCountCommentArgs() interface{} {
	return &CountCommentArgs{}
}

func newCountCommentResult() interface{} {
	return &CountCommentResult{}
}

type CountCommentArgs struct {
	Req *commentDomain.DoutokCountCommentReq
}

func (p *CountCommentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(commentDomain.DoutokCountCommentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountCommentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountCommentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountCommentArgs) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokCountCommentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountCommentArgs_Req_DEFAULT *commentDomain.DoutokCountCommentReq

func (p *CountCommentArgs) GetReq() *commentDomain.DoutokCountCommentReq {
	if !p.IsSetReq() {
		return CountCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type CountCommentResult struct {
	Success *commentDomain.DoutokCountCommentResp
}

var CountCommentResult_Success_DEFAULT *commentDomain.DoutokCountCommentResp

func (p *CountCommentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(commentDomain.DoutokCountCommentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountCommentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountCommentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountCommentResult) Unmarshal(in []byte) error {
	msg := new(commentDomain.DoutokCountCommentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountCommentResult) GetSuccess() *commentDomain.DoutokCountCommentResp {
	if !p.IsSetSuccess() {
		return CountCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*commentDomain.DoutokCountCommentResp)
}

func (p *CountCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) AddComment(ctx context.Context, Req *commentDomain.DoutokAddCommentReq) (r *commentDomain.DoutokAddCommentResp, err error) {
	var _args AddCommentArgs
	_args.Req = Req
	var _result AddCommentResult
	if err = p.c.Call(ctx, "AddComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RmComment(ctx context.Context, Req *commentDomain.DoutokRmCommentReq) (r *commentDomain.DoutokAddCommentResp, err error) {
	var _args RmCommentArgs
	_args.Req = Req
	var _result RmCommentResult
	if err = p.c.Call(ctx, "RmComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListComment(ctx context.Context, Req *commentDomain.DoutokListCommentReq) (r *commentDomain.DoutokListCommentResp, err error) {
	var _args ListCommentArgs
	_args.Req = Req
	var _result ListCommentResult
	if err = p.c.Call(ctx, "ListComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountComment(ctx context.Context, Req *commentDomain.DoutokCountCommentReq) (r *commentDomain.DoutokCountCommentResp, err error) {
	var _args CountCommentArgs
	_args.Req = Req
	var _result CountCommentResult
	if err = p.c.Call(ctx, "CountComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
