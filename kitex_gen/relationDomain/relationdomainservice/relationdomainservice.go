// Code generated by Kitex v0.4.4. DO NOT EDIT.

package relationdomainservice

import (
	"context"
	"fmt"
	relationDomain "github.com/TremblingV5/DouTok/kitex_gen/relationDomain"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return relationDomainServiceServiceInfo
}

var relationDomainServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "RelationDomainService"
	handlerType := (*relationDomain.RelationDomainService)(nil)
	methods := map[string]kitex.MethodInfo{
		"AddRelation":   kitex.NewMethodInfo(addRelationHandler, newAddRelationArgs, newAddRelationResult, false),
		"RmRelation":    kitex.NewMethodInfo(rmRelationHandler, newRmRelationArgs, newRmRelationResult, false),
		"ListRelation":  kitex.NewMethodInfo(listRelationHandler, newListRelationArgs, newListRelationResult, false),
		"CountRelation": kitex.NewMethodInfo(countRelationHandler, newCountRelationArgs, newCountRelationResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "relationDomain",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.4.4",
		Extra:           extra,
	}
	return svcInfo
}

func addRelationHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(relationDomain.DoutokAddRelationRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(relationDomain.RelationDomainService).AddRelation(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AddRelationArgs:
		success, err := handler.(relationDomain.RelationDomainService).AddRelation(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddRelationResult)
		realResult.Success = success
	}
	return nil
}
func newAddRelationArgs() interface{} {
	return &AddRelationArgs{}
}

func newAddRelationResult() interface{} {
	return &AddRelationResult{}
}

type AddRelationArgs struct {
	Req *relationDomain.DoutokAddRelationRequest
}

func (p *AddRelationArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(relationDomain.DoutokAddRelationRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AddRelationArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AddRelationArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AddRelationArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AddRelationArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AddRelationArgs) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokAddRelationRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddRelationArgs_Req_DEFAULT *relationDomain.DoutokAddRelationRequest

func (p *AddRelationArgs) GetReq() *relationDomain.DoutokAddRelationRequest {
	if !p.IsSetReq() {
		return AddRelationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddRelationArgs) IsSetReq() bool {
	return p.Req != nil
}

type AddRelationResult struct {
	Success *relationDomain.DoutokAddRelationResponse
}

var AddRelationResult_Success_DEFAULT *relationDomain.DoutokAddRelationResponse

func (p *AddRelationResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(relationDomain.DoutokAddRelationResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AddRelationResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AddRelationResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AddRelationResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AddRelationResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AddRelationResult) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokAddRelationResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddRelationResult) GetSuccess() *relationDomain.DoutokAddRelationResponse {
	if !p.IsSetSuccess() {
		return AddRelationResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddRelationResult) SetSuccess(x interface{}) {
	p.Success = x.(*relationDomain.DoutokAddRelationResponse)
}

func (p *AddRelationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rmRelationHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(relationDomain.DoutokRmRelationRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(relationDomain.RelationDomainService).RmRelation(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RmRelationArgs:
		success, err := handler.(relationDomain.RelationDomainService).RmRelation(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RmRelationResult)
		realResult.Success = success
	}
	return nil
}
func newRmRelationArgs() interface{} {
	return &RmRelationArgs{}
}

func newRmRelationResult() interface{} {
	return &RmRelationResult{}
}

type RmRelationArgs struct {
	Req *relationDomain.DoutokRmRelationRequest
}

func (p *RmRelationArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(relationDomain.DoutokRmRelationRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RmRelationArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RmRelationArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RmRelationArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RmRelationArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RmRelationArgs) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokRmRelationRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RmRelationArgs_Req_DEFAULT *relationDomain.DoutokRmRelationRequest

func (p *RmRelationArgs) GetReq() *relationDomain.DoutokRmRelationRequest {
	if !p.IsSetReq() {
		return RmRelationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RmRelationArgs) IsSetReq() bool {
	return p.Req != nil
}

type RmRelationResult struct {
	Success *relationDomain.DoutokRmRelationResponse
}

var RmRelationResult_Success_DEFAULT *relationDomain.DoutokRmRelationResponse

func (p *RmRelationResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(relationDomain.DoutokRmRelationResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RmRelationResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RmRelationResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RmRelationResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RmRelationResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RmRelationResult) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokRmRelationResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RmRelationResult) GetSuccess() *relationDomain.DoutokRmRelationResponse {
	if !p.IsSetSuccess() {
		return RmRelationResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RmRelationResult) SetSuccess(x interface{}) {
	p.Success = x.(*relationDomain.DoutokRmRelationResponse)
}

func (p *RmRelationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func listRelationHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(relationDomain.DoutokListRelationRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(relationDomain.RelationDomainService).ListRelation(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListRelationArgs:
		success, err := handler.(relationDomain.RelationDomainService).ListRelation(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListRelationResult)
		realResult.Success = success
	}
	return nil
}
func newListRelationArgs() interface{} {
	return &ListRelationArgs{}
}

func newListRelationResult() interface{} {
	return &ListRelationResult{}
}

type ListRelationArgs struct {
	Req *relationDomain.DoutokListRelationRequest
}

func (p *ListRelationArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(relationDomain.DoutokListRelationRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListRelationArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListRelationArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListRelationArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListRelationArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListRelationArgs) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokListRelationRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListRelationArgs_Req_DEFAULT *relationDomain.DoutokListRelationRequest

func (p *ListRelationArgs) GetReq() *relationDomain.DoutokListRelationRequest {
	if !p.IsSetReq() {
		return ListRelationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListRelationArgs) IsSetReq() bool {
	return p.Req != nil
}

type ListRelationResult struct {
	Success *relationDomain.DoutokListRelationResponse
}

var ListRelationResult_Success_DEFAULT *relationDomain.DoutokListRelationResponse

func (p *ListRelationResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(relationDomain.DoutokListRelationResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListRelationResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListRelationResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListRelationResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListRelationResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListRelationResult) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokListRelationResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListRelationResult) GetSuccess() *relationDomain.DoutokListRelationResponse {
	if !p.IsSetSuccess() {
		return ListRelationResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListRelationResult) SetSuccess(x interface{}) {
	p.Success = x.(*relationDomain.DoutokListRelationResponse)
}

func (p *ListRelationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func countRelationHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(relationDomain.DoutokCountRelationRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(relationDomain.RelationDomainService).CountRelation(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountRelationArgs:
		success, err := handler.(relationDomain.RelationDomainService).CountRelation(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountRelationResult)
		realResult.Success = success
	}
	return nil
}
func newCountRelationArgs() interface{} {
	return &CountRelationArgs{}
}

func newCountRelationResult() interface{} {
	return &CountRelationResult{}
}

type CountRelationArgs struct {
	Req *relationDomain.DoutokCountRelationRequest
}

func (p *CountRelationArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(relationDomain.DoutokCountRelationRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountRelationArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountRelationArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountRelationArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountRelationArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountRelationArgs) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokCountRelationRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountRelationArgs_Req_DEFAULT *relationDomain.DoutokCountRelationRequest

func (p *CountRelationArgs) GetReq() *relationDomain.DoutokCountRelationRequest {
	if !p.IsSetReq() {
		return CountRelationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountRelationArgs) IsSetReq() bool {
	return p.Req != nil
}

type CountRelationResult struct {
	Success *relationDomain.DoutokCountRelationResponse
}

var CountRelationResult_Success_DEFAULT *relationDomain.DoutokCountRelationResponse

func (p *CountRelationResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(relationDomain.DoutokCountRelationResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountRelationResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountRelationResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountRelationResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountRelationResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountRelationResult) Unmarshal(in []byte) error {
	msg := new(relationDomain.DoutokCountRelationResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountRelationResult) GetSuccess() *relationDomain.DoutokCountRelationResponse {
	if !p.IsSetSuccess() {
		return CountRelationResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountRelationResult) SetSuccess(x interface{}) {
	p.Success = x.(*relationDomain.DoutokCountRelationResponse)
}

func (p *CountRelationResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) AddRelation(ctx context.Context, Req *relationDomain.DoutokAddRelationRequest) (r *relationDomain.DoutokAddRelationResponse, err error) {
	var _args AddRelationArgs
	_args.Req = Req
	var _result AddRelationResult
	if err = p.c.Call(ctx, "AddRelation", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RmRelation(ctx context.Context, Req *relationDomain.DoutokRmRelationRequest) (r *relationDomain.DoutokRmRelationResponse, err error) {
	var _args RmRelationArgs
	_args.Req = Req
	var _result RmRelationResult
	if err = p.c.Call(ctx, "RmRelation", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListRelation(ctx context.Context, Req *relationDomain.DoutokListRelationRequest) (r *relationDomain.DoutokListRelationResponse, err error) {
	var _args ListRelationArgs
	_args.Req = Req
	var _result ListRelationResult
	if err = p.c.Call(ctx, "ListRelation", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountRelation(ctx context.Context, Req *relationDomain.DoutokCountRelationRequest) (r *relationDomain.DoutokCountRelationResponse, err error) {
	var _args CountRelationArgs
	_args.Req = Req
	var _result CountRelationResult
	if err = p.c.Call(ctx, "CountRelation", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
