// Code generated by Kitex v0.4.4. DO NOT EDIT.

package videodomainservice

import (
	"context"
	"fmt"
	entity "github.com/TremblingV5/DouTok/kitex_gen/entity"
	videoDomain "github.com/TremblingV5/DouTok/kitex_gen/videoDomain"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return videoDomainServiceServiceInfo
}

var videoDomainServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "VideoDomainService"
	handlerType := (*videoDomain.VideoDomainService)(nil)
	methods := map[string]kitex.MethodInfo{
		"GetFeed":      kitex.NewMethodInfo(getFeedHandler, newGetFeedArgs, newGetFeedResult, false),
		"AddPublish":   kitex.NewMethodInfo(addPublishHandler, newAddPublishArgs, newAddPublishResult, false),
		"ListPublish":  kitex.NewMethodInfo(listPublishHandler, newListPublishArgs, newListPublishResult, false),
		"CountPublish": kitex.NewMethodInfo(countPublishHandler, newCountPublishArgs, newCountPublishResult, false),
		"GetVideoInfo": kitex.NewMethodInfo(getVideoInfoHandler, newGetVideoInfoArgs, newGetVideoInfoResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "videoDomain",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.4.4",
		Extra:           extra,
	}
	return svcInfo
}

func getFeedHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoDomain.DoutokGetFeedRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoDomain.VideoDomainService).GetFeed(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetFeedArgs:
		success, err := handler.(videoDomain.VideoDomainService).GetFeed(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFeedResult)
		realResult.Success = success
	}
	return nil
}
func newGetFeedArgs() interface{} {
	return &GetFeedArgs{}
}

func newGetFeedResult() interface{} {
	return &GetFeedResult{}
}

type GetFeedArgs struct {
	Req *videoDomain.DoutokGetFeedRequest
}

func (p *GetFeedArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoDomain.DoutokGetFeedRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetFeedArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetFeedArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetFeedArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetFeedArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetFeedArgs) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokGetFeedRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFeedArgs_Req_DEFAULT *videoDomain.DoutokGetFeedRequest

func (p *GetFeedArgs) GetReq() *videoDomain.DoutokGetFeedRequest {
	if !p.IsSetReq() {
		return GetFeedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFeedArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetFeedResult struct {
	Success *videoDomain.DoutokGetFeedResponse
}

var GetFeedResult_Success_DEFAULT *videoDomain.DoutokGetFeedResponse

func (p *GetFeedResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoDomain.DoutokGetFeedResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetFeedResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetFeedResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetFeedResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetFeedResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetFeedResult) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokGetFeedResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFeedResult) GetSuccess() *videoDomain.DoutokGetFeedResponse {
	if !p.IsSetSuccess() {
		return GetFeedResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFeedResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoDomain.DoutokGetFeedResponse)
}

func (p *GetFeedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func addPublishHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoDomain.DoutokAddPublishRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoDomain.VideoDomainService).AddPublish(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AddPublishArgs:
		success, err := handler.(videoDomain.VideoDomainService).AddPublish(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddPublishResult)
		realResult.Success = success
	}
	return nil
}
func newAddPublishArgs() interface{} {
	return &AddPublishArgs{}
}

func newAddPublishResult() interface{} {
	return &AddPublishResult{}
}

type AddPublishArgs struct {
	Req *videoDomain.DoutokAddPublishRequest
}

func (p *AddPublishArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoDomain.DoutokAddPublishRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *AddPublishArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *AddPublishArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *AddPublishArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AddPublishArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AddPublishArgs) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokAddPublishRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddPublishArgs_Req_DEFAULT *videoDomain.DoutokAddPublishRequest

func (p *AddPublishArgs) GetReq() *videoDomain.DoutokAddPublishRequest {
	if !p.IsSetReq() {
		return AddPublishArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddPublishArgs) IsSetReq() bool {
	return p.Req != nil
}

type AddPublishResult struct {
	Success *videoDomain.DoutokAddPublishResponse
}

var AddPublishResult_Success_DEFAULT *videoDomain.DoutokAddPublishResponse

func (p *AddPublishResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoDomain.DoutokAddPublishResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *AddPublishResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *AddPublishResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *AddPublishResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AddPublishResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AddPublishResult) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokAddPublishResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddPublishResult) GetSuccess() *videoDomain.DoutokAddPublishResponse {
	if !p.IsSetSuccess() {
		return AddPublishResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddPublishResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoDomain.DoutokAddPublishResponse)
}

func (p *AddPublishResult) IsSetSuccess() bool {
	return p.Success != nil
}

func listPublishHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoDomain.DoutokListPublishRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoDomain.VideoDomainService).ListPublish(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListPublishArgs:
		success, err := handler.(videoDomain.VideoDomainService).ListPublish(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListPublishResult)
		realResult.Success = success
	}
	return nil
}
func newListPublishArgs() interface{} {
	return &ListPublishArgs{}
}

func newListPublishResult() interface{} {
	return &ListPublishResult{}
}

type ListPublishArgs struct {
	Req *videoDomain.DoutokListPublishRequest
}

func (p *ListPublishArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoDomain.DoutokListPublishRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListPublishArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListPublishArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListPublishArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListPublishArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListPublishArgs) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokListPublishRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListPublishArgs_Req_DEFAULT *videoDomain.DoutokListPublishRequest

func (p *ListPublishArgs) GetReq() *videoDomain.DoutokListPublishRequest {
	if !p.IsSetReq() {
		return ListPublishArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListPublishArgs) IsSetReq() bool {
	return p.Req != nil
}

type ListPublishResult struct {
	Success *videoDomain.DoutokListPublishResponse
}

var ListPublishResult_Success_DEFAULT *videoDomain.DoutokListPublishResponse

func (p *ListPublishResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoDomain.DoutokListPublishResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListPublishResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListPublishResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListPublishResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListPublishResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListPublishResult) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokListPublishResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListPublishResult) GetSuccess() *videoDomain.DoutokListPublishResponse {
	if !p.IsSetSuccess() {
		return ListPublishResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListPublishResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoDomain.DoutokListPublishResponse)
}

func (p *ListPublishResult) IsSetSuccess() bool {
	return p.Success != nil
}

func countPublishHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoDomain.DoutokCountPublishRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoDomain.VideoDomainService).CountPublish(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountPublishArgs:
		success, err := handler.(videoDomain.VideoDomainService).CountPublish(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountPublishResult)
		realResult.Success = success
	}
	return nil
}
func newCountPublishArgs() interface{} {
	return &CountPublishArgs{}
}

func newCountPublishResult() interface{} {
	return &CountPublishResult{}
}

type CountPublishArgs struct {
	Req *videoDomain.DoutokCountPublishRequest
}

func (p *CountPublishArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoDomain.DoutokCountPublishRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountPublishArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountPublishArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountPublishArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountPublishArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountPublishArgs) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokCountPublishRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountPublishArgs_Req_DEFAULT *videoDomain.DoutokCountPublishRequest

func (p *CountPublishArgs) GetReq() *videoDomain.DoutokCountPublishRequest {
	if !p.IsSetReq() {
		return CountPublishArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountPublishArgs) IsSetReq() bool {
	return p.Req != nil
}

type CountPublishResult struct {
	Success *videoDomain.DoutokCountPublishResponse
}

var CountPublishResult_Success_DEFAULT *videoDomain.DoutokCountPublishResponse

func (p *CountPublishResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(videoDomain.DoutokCountPublishResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountPublishResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountPublishResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountPublishResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountPublishResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountPublishResult) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokCountPublishResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountPublishResult) GetSuccess() *videoDomain.DoutokCountPublishResponse {
	if !p.IsSetSuccess() {
		return CountPublishResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountPublishResult) SetSuccess(x interface{}) {
	p.Success = x.(*videoDomain.DoutokCountPublishResponse)
}

func (p *CountPublishResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVideoInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(videoDomain.DoutokGetVideoInfoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(videoDomain.VideoDomainService).GetVideoInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVideoInfoArgs:
		success, err := handler.(videoDomain.VideoDomainService).GetVideoInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideoInfoResult)
		realResult.Success = success
	}
	return nil
}
func newGetVideoInfoArgs() interface{} {
	return &GetVideoInfoArgs{}
}

func newGetVideoInfoResult() interface{} {
	return &GetVideoInfoResult{}
}

type GetVideoInfoArgs struct {
	Req *videoDomain.DoutokGetVideoInfoRequest
}

func (p *GetVideoInfoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(videoDomain.DoutokGetVideoInfoRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetVideoInfoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetVideoInfoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetVideoInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVideoInfoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideoInfoArgs) Unmarshal(in []byte) error {
	msg := new(videoDomain.DoutokGetVideoInfoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideoInfoArgs_Req_DEFAULT *videoDomain.DoutokGetVideoInfoRequest

func (p *GetVideoInfoArgs) GetReq() *videoDomain.DoutokGetVideoInfoRequest {
	if !p.IsSetReq() {
		return GetVideoInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideoInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVideoInfoResult struct {
	Success *entity.Video
}

var GetVideoInfoResult_Success_DEFAULT *entity.Video

func (p *GetVideoInfoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(entity.Video)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetVideoInfoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetVideoInfoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetVideoInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVideoInfoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideoInfoResult) Unmarshal(in []byte) error {
	msg := new(entity.Video)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideoInfoResult) GetSuccess() *entity.Video {
	if !p.IsSetSuccess() {
		return GetVideoInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideoInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*entity.Video)
}

func (p *GetVideoInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) GetFeed(ctx context.Context, Req *videoDomain.DoutokGetFeedRequest) (r *videoDomain.DoutokGetFeedResponse, err error) {
	var _args GetFeedArgs
	_args.Req = Req
	var _result GetFeedResult
	if err = p.c.Call(ctx, "GetFeed", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddPublish(ctx context.Context, Req *videoDomain.DoutokAddPublishRequest) (r *videoDomain.DoutokAddPublishResponse, err error) {
	var _args AddPublishArgs
	_args.Req = Req
	var _result AddPublishResult
	if err = p.c.Call(ctx, "AddPublish", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListPublish(ctx context.Context, Req *videoDomain.DoutokListPublishRequest) (r *videoDomain.DoutokListPublishResponse, err error) {
	var _args ListPublishArgs
	_args.Req = Req
	var _result ListPublishResult
	if err = p.c.Call(ctx, "ListPublish", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountPublish(ctx context.Context, Req *videoDomain.DoutokCountPublishRequest) (r *videoDomain.DoutokCountPublishResponse, err error) {
	var _args CountPublishArgs
	_args.Req = Req
	var _result CountPublishResult
	if err = p.c.Call(ctx, "CountPublish", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideoInfo(ctx context.Context, Req *videoDomain.DoutokGetVideoInfoRequest) (r *entity.Video, err error) {
	var _args GetVideoInfoArgs
	_args.Req = Req
	var _result GetVideoInfoResult
	if err = p.c.Call(ctx, "GetVideoInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
